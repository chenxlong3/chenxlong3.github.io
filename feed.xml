<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://chenxlong3.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://chenxlong3.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-01-26T06:36:17+00:00</updated><id>https://chenxlong3.github.io/feed.xml</id><title type="html">Xiaolong Chen</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html"></title><link href="https://chenxlong3.github.io/blog/2026/2023-03-10-wget-conn-refused/" rel="alternate" type="text/html" title=""/><published>2026-01-26T06:36:17+00:00</published><updated>2026-01-26T06:36:17+00:00</updated><id>https://chenxlong3.github.io/blog/2026/2023-03-10-wget-conn-refused</id><content type="html" xml:base="https://chenxlong3.github.io/blog/2026/2023-03-10-wget-conn-refused/"><![CDATA[<p>用wget或者curl获取github文件的时候报出connection refused错误，可以通过以下方式解决：</p> <p>在本机的host文件添加以下几行：</p> <p>199.232.68.133 raw.githubusercontent.com</p> <p>199.232.68.133 user-images.githubusercontent.com</p> <p>199.232.68.133 avatars2.githubusercontent.com</p> <p>199.232.68.133 avatars1.githubusercontent.com</p> <p><a href="https://github.com/hawtim/hawtim.github.io/issues/10">https://github.com/hawtim/hawtim.github.io/issues/10</a></p> <p><a href="https://unix.stackexchange.com/questions/228412/how-to-wget-a-github-file">https://unix.stackexchange.com/questions/228412/how-to-wget-a-github-file</a></p>]]></content><author><name></name></author></entry><entry><title type="html">DiffusionNFT环境配置踩坑合集</title><link href="https://chenxlong3.github.io/blog/2026/NFTenv/" rel="alternate" type="text/html" title="DiffusionNFT环境配置踩坑合集"/><published>2026-01-06T00:00:00+00:00</published><updated>2026-01-06T00:00:00+00:00</updated><id>https://chenxlong3.github.io/blog/2026/NFTenv</id><content type="html" xml:base="https://chenxlong3.github.io/blog/2026/NFTenv/"><![CDATA[<ol> <li> <p><strong>conda-pack Files managed by conda were found to have been deleted/overwritten的问题</strong></p> <p><a href="https://blog.csdn.net/huanyan777/article/details/155506096">解决conda pack的 Files managed by conda were found to have been deleted/overwritten的问题_conda pack报错deleted-CSDN博客</a></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> conda <span class="nb">install</span> <span class="nt">--force-reinstall</span> <span class="o">[</span>pkg1][pkg2]
</code></pre></div> </div> </li> <li> <p>pip安装flash-attn报错no module named ‘torch’</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> pip <span class="nb">install </span>flash-attn <span class="nt">--no-build-isolation</span>
</code></pre></div> </div> </li> <li> <p>xformers与pytorch版本问题，查看下面github链接</p> <p><a href="https://github.com/facebookresearch/xformers/releases?page=2">https://github.com/facebookresearch/xformers/releases?page=2</a></p> <p><a href="https://blog.csdn.net/cainiaoshileyuan/article/details/148000602">https://blog.csdn.net/cainiaoshileyuan/article/details/148000602</a></p> </li> <li> <p>清华镜像源临时使用：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> pip <span class="nb">install</span> <span class="nt">-i</span> https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple some-package
 conda <span class="nb">install </span>xxx <span class="nt">-c</span> https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main
</code></pre></div> </div> <p><a href="https://mirror.tuna.tsinghua.edu.cn/help/pypi/">https://mirror.tuna.tsinghua.edu.cn/help/pypi/</a></p> <p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</a></p> </li> <li> <p>conda 安装 cuda-toolkit，注意不同版本对应cuda不同版本，12.3 for cuda12.4</p> <p><a href="https://anaconda.org/channels/nvidia/packages/cuda-toolkit/overview">https://anaconda.org/channels/nvidia/packages/cuda-toolkit/overview</a></p> </li> <li> <p>Hugging face镜像站使用</p> <p><a href="https://zhuanlan.zhihu.com/p/663712983">https://zhuanlan.zhihu.com/p/663712983</a></p> </li> <li> <p>apt安装的cmake版本过低，用pip。安装pyarrow时会用到cmake。</p> <p>pip install –upgrade cmake</p> <p><a href="https://askubuntu.com/questions/355565/how-do-i-install-the-latest-version-of-cmake-from-the-command-line">https://askubuntu.com/questions/355565/how-do-i-install-the-latest-version-of-cmake-from-the-command-line</a></p> </li> <li> <p>nvcc command not found</p> <p>用conda安装cuda-toolkit，见5。nvcc与cuda版本不同，通过改cuda-toolkit版本进行解决</p> <p><a href="https://zhuanlan.zhihu.com/p/21676609751">https://zhuanlan.zhihu.com/p/21676609751</a></p> </li> <li> <p><strong>libgl.so.1: cannot open shared object file: no such file or directory</strong></p> <p>apt-get install libgl1</p> <p><a href="https://itsmycode.com/importerror-libgl-so-1-cannot-open-shared-object-file-no-such-file-or-directory/">https://itsmycode.com/importerror-libgl-so-1-cannot-open-shared-object-file-no-such-file-or-directory/</a></p> </li> <li> <p>torch cuda下载，南京大学镜像源</p> <p><a href="https://zhuanlan.zhihu.com/p/1909015652892644209">https://zhuanlan.zhihu.com/p/1909015652892644209</a></p> <p>不确定清华源可不可以用，参考： <a href="https://blog.csdn.net/cyy0789/article/details/131137525">https://blog.csdn.net/cyy0789/article/details/131137525</a></p> </li> <li> <p><strong>No module named ‘mmcv._ext’</strong></p> <p>when installing mmcv, should use <code class="language-plaintext highlighter-rouge">--no-build-isolation</code></p> </li> <li> <p>通过git安装mmcv时，要重命名git文件夹，否则import mmcv的功能时会经常发生找不到module的问题。</p> </li> <li> <p><strong>Pytorch distributed RuntimeError: Address already in use</strong></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>torchrun <span class="nt">--nproc_per_node</span><span class="o">=</span>1 <span class="nt">--master_port</span><span class="o">=</span>29501 ./train_nft_sd3.py <span class="nt">--config</span> config/nft.py:sd3_geneval
</code></pre></div> </div> </li> </ol>]]></content><author><name></name></author><category term="Techniques"/><summary type="html"><![CDATA[conda-pack Files managed by conda were found to have been deleted/overwritten的问题]]></summary></entry><entry><title type="html">社交网络影响力最大化：Are we there yet?</title><link href="https://chenxlong3.github.io/blog/2025/IM/" rel="alternate" type="text/html" title="社交网络影响力最大化：Are we there yet?"/><published>2025-11-14T09:50:54+00:00</published><updated>2025-11-14T09:50:54+00:00</updated><id>https://chenxlong3.github.io/blog/2025/IM</id><content type="html" xml:base="https://chenxlong3.github.io/blog/2025/IM/"><![CDATA[<p>社交网络影响力最大化（Influence Maximization）问题自从2003年被Kempe等人提出，已经被研究了二十余年。那么，现在最先进的算法是否已经足够好了？这个领域是不是已经没得做了？还能往哪方面深挖（灌水）呢？</p> <h1 id="问题定义">问题定义</h1> <p>给定一个社交网络（有向图）$G=(V,E)$，一个信息传播模型 $\mathcal{M}$，影响力最大化问题意图找到一个大小为$k$的节点集合 $S$ ，使得它们在 $G$ 中基于传播模型 $\mathcal{M}$ 的影响力 $\sigma_{\mathcal{M}}(S)$ 最大。</p> <h2 id="传播模型">传播模型</h2> <p>此前的问题定义也还是算比较抽象，因为传播模型还并未确定，针对不同的传播模型，该优化问题也许会有不同的性质。接下来我们介绍一种最广泛使用的传播模型之一——独立级联模型（Independent Cascade）。</p> <p>IC模型下，每个节点有激活和未激活两种状态，给定种子节点集合 $S$， 影响力的传播与计算方式如下：</p> <ol> <li>在第1步，所有种子节点被激活，其余节点处于不激活状态。</li> <li>在第 $t$ 步新激活的节点 $u$ ，对每个 $u$ 的未激活出邻居 $v$， 有且仅有一次机会以概率在 $t+1$步激活 $v$。</li> </ol> <p>当没有新节点被激活时，传播过程停止。一次传播过程 $\phi$ 中，我们把 $S$激活的点的数量记为 $I_\phi(S)$。$S$ 的影响力被定义为传播过程中被激活的点的数量的期望，记作 $\sigma(S)$，即:</p> \[\sigma(S) = \sum_{\phi \sim G} \Pr[\phi] I_{\phi}(S)\] <h2 id="函数性质">函数性质</h2> <p>解决问题的第一步是要充分了解这个问题的性质。从计算复杂性的角度看，在IC模型下，影响力最大化是NP-hard的，以及 $\sigma(S)$ 的计算是 #P-hard的。基本就是说这个问题的一般情况很难得到最优解，并且函数值都没法精确计算。不过好消息是，目标函数具有单调（monotone）和次模（submodular）的性质。假设我们能够准确算出给定节点集的影响力 $\sigma(S)$，根据次模优化（submodular optimization）的经典结论，简单的贪心算法可以给出$1-1/\mathrm{e}$的近似比（即$\sigma(S_g) \geq (1-1/\mathrm{e})\text{OPT}$，$\text{OPT}$为最优解）。</p> <h1 id="naive-method-基于蒙特卡洛模拟的贪心算法">Naive Method: 基于蒙特卡洛模拟的贪心算法</h1> <p>然而，根据此前所述， $\sigma(S)$没法被精确计算。于是，二十年来，研究者们都在想办法精确估计这个函数。最简单的方式就是就是模拟传播过程$r$次，然后取平均，用来估计 $S$ 的影响力。因为估算误差的存在，这种基于蒙特卡洛模拟的贪心算法最终会获得$1-1/\mathrm{e}-\varepsilon$的近似比。一般来讲，每一次的估计误差$\gamma$（注：$\gamma$为相对/乘性误差，即$(1-\gamma)\sigma(S) \leq \hat{\sigma}(S) \leq (1+\gamma)\sigma(S)$）和最终的近似误差$\varepsilon$的关系大约是$\gamma = \Theta(\varepsilon/k)$。可以抽象地理解成估计误差会随着每一轮的迭代而累积。也就是说，保持最终的近似误差不变，随着需要选取的节点数量增多，我们需要越来越精确的估计（即$\gamma$越来越小），于是导致越来越多的开销。</p> <p>但蒙特卡洛模拟每次需要的时间很长（很可能到$O(m)$量级），并且要大量的模拟次数来达到最后的理论保证，所以在很多文章的实验中，这个理论保证通常都会被舍弃，模拟次数都被设置成10000这样一个固定数字。自2003后的十年里，研究者们提出了各种各样的方法来提出高效的方法来解决IM问题，然而，始终没有方法能够在数百万节点的图上得到具有理论保证的解，直到2014（实际上在更早的时候，未经同行评审的版本已经放在arxiv上）。</p> <h1 id="state-of-the-art-反向影响力采样">State-of-the-art: 反向影响力采样</h1> <h2 id="基本思想">基本思想</h2> <p>2014年，Christrian Borgs等人在理论领域顶会SODA上发表了<strong>Maximizing social influence in nearly optimal time</strong>这篇文章，提出了著名的反向影响力采样（Reverse Influence Sampling, RIS）框架（注：在原始文章里作者们把他们的方法称为Hypergraph，反向影响力采样是后来的文章对该方法的命名）。为了帮助读者更好地理解RIS，我们先介绍反向可达集（Reverse Reachable Sets， RR-sets）的概念。</p> <p>给定一个节点$v$和一个确定的图$\phi$，一个以$v$为根节点的RR-set包含$\phi$中所有能到达$v$的点。基于此，一个<strong>随机</strong>反向可达集（random RR-set）按照如下方式构建：(i) 均匀随机采样一个点$v$，(ii) 在一个随机的传播实例$\phi$中，存储所有能到达$v$的点，它们构成的集合记作RR-set $R$。这个定义还是有点晦涩，事实上，在IC模型下，我们构建一个random RR-set就是先随机选一个点，然后从这个点开始反向传播，把能reach的点都存到$R$中。</p> <p>对于一个种子节点集合$S$来说，如果$S$中有至少一个点在$R$中（即$S\cap R \neq \emptyset$），我们说$S$ cover了$R$。对于一组RR sets $\mathcal{R}$来说，$S$的coverage就被定义为被$S$ cover的RR-sets的数量，即$\Lambda_{\mathcal{R}}(S) = \sum_{R \in \mathcal{R}} \mathbb{I}(R\cap S\neq \emptyset)$。</p> <p>直觉上，如果一个种子节点影响力很高，那么它应该会经常出现在别的节点的RR-sets里，也就是说，它的coverage会很大。Borgs等人证明了这个coverage可以用来无偏地估计$S$的影响力。数学上来说，就是$\sigma(S)=n\cdot \mathbb{E}[ \frac{\Lambda_{\mathcal{R}}(S)}{ \mid \mathcal{R} \mid} ]$，这里的期望是作用在random RR-sets上，即根节点的随机性和传播过程的随机性。High-level地来讲，这个式子的意思就是假设有一堆random RR-sets，他们被$S$ cover的比例就可以（期望上）视作被$S$影响节点占总节点数的比例。 一个简单的示意图如下：</p> <p><img src="/assets/img/posts/IM/IM_cover.png" style="width: 80%; height: auto; margin:auto; display:block;"/></p> <h2 id="算法框架">算法框架</h2> <p>基于上述估计方法，RIS框架基本分两步走：(i) 采样大量RR-sets，随后 (ii) 找coverage最大的$S$。而第二步，即优化$\Lambda_{\mathcal{R}}(S)$， 实质上就是经典的最大覆盖问题（maximum coverage），贪心算法可以在线性时间复杂度下完成。剩下的就是第一步的事情：怎么决定采样多少RR-sets？此后的一系列工作都在围绕这个问题进行改进。Borgs等人通过数采样过程中遍历的边的数目来确定RR-sets是否足够。他们提出只要总共遍历的边数超过$cmk\log(n)/\varepsilon^2$ （$c$为某个常数），就能以较高概率获得具有理论保证的近似解。随后的TIM提出上述方式是有问题的，因为这种采样会使得采样的RR-sets之间并不完全独立，影响Chernoff不等式的使用。TIM从RR-sets的数量角度来思考，提出当RR-sets的数目大于$O(\frac{nk\log n }{\varepsilon^2 \text{OPT}})$时，我们能以较高概率获得具有理论保证的近似解。这种框架一直被沿用至今。此后的IMM、OPIM等，都是在想办法减少RR-sets的数量，去达到相同的$1-1/\mathrm{e}-\varepsilon$的理论保证。</p> <h2 id="好在哪里">好在哪里？</h2> <p>从时间复杂度上来说，RIS-based的方法当然是显著优于其他方法，但它到底好在哪里呢？首先，在RIS的框架下，我们的估算函数$\Lambda_{\mathcal{R}}(S)$也是monotone and submodular的，使得贪心算法能获得$1-1/\mathrm{e}$的近似解。这个特性让我们只需要bound住一个size-$k$种子节点集合的<strong>绝对误差</strong>在$O(\varepsilon)\text{OPT}$内就行。更细节来说，这种近似的模式可以大致表示成下面的形式：</p> \[\begin{align*} \sigma(S) &amp;\geq \frac{n}{\theta}\Lambda_{\mathcal{R}}(S) - O(\varepsilon)\text{OPT} \\ &amp; \geq (1-1/\mathrm{e})\frac{n}{\theta}\Lambda_{\mathcal{R}}(S^\circ) - O(\varepsilon)\text{OPT}\\ &amp;\geq (1-1/\mathrm{e}-O(\varepsilon)) \sigma(S^\circ) -O(\varepsilon)\text{OPT}\\ &amp;=(1-1/\mathrm{e}-O(\varepsilon))\text{OPT} \end{align*}\] <p>这种近似模式需要的采样数量更少，因为不再需要非常精确地估计每一个点的influence。此外，对coverage函数$\Lambda_{\mathcal{R}}(S)$的优化也可以高效完成。而且，一般来讲，RR-set的大小一般不会很大，而在此前介绍的蒙特卡洛估计方式中，随着选的点越来越多，一次模拟（采样）的时间会越来越长。</p> <p>以上几点就是RIS这个框架比较高效的主要原因。</p> <h2 id="问题">问题</h2> <p>事实上，虽然所有文章的实验效果都很好，但在各种setting上跑一下代码就会发现还是有一些问题的。主流的文章里，都把每条边$\langle u,v \rangle$的概率设置成$1/d_{in}(v)$，其中$d_{in}(v)$是$v$的入度。这种设置其实比较tricky，因为这样的话相当于做反向采样的时候，对每个点来说期望只有一个邻居被采到，使得RR-sets整体来说都不会太大，而且这种设定下，最优解的influence也不会很小，所以整体运行时间较快。</p> <p>然而，当每条边的传播概率都很高时，RR-sets会很大，采样会很耗时间，不过这一点在Qintian Guo等人的文章里已经得到部分解决，他们提出先根据很少的采样选出一些哨兵节点，然后在后续的每个RR-set的采样中，如果遇到哨兵节点就立即停止，这样的方式可以减小RR-set的size。但这个只适用于节点选取，当涉及其他变种问题时（如对给定节点集合的影响力估计），这种方式就不能直接使用了。第二种情况就是当每条边的传播概率都很低时，最优解的influence变得很小，达到理论保证需要的RR-sets数量也会非常大，使得算法运行时间变长。</p> <p>值得一提的是，RIS这种估计方式的方差实际上是比蒙特卡洛方法要大的，但采样的过程比蒙特卡洛快很多。有没有办法结合正向和反向的传播，使得估算更加高效，也是一个潜在的研究方向。</p> <h1 id="the-road-ahead">The Road Ahead</h1> <p>除了研究IM本身的一系列主线文章，基于它的变种问题也有不少，像是改传播模型、改目标函数、改限制条件、Adaptive和dynamic settings之类的。问题总是能捏造出来的，但要提出新问题的话，motivation是非常重要的，再怎么强调都不为过，再辅以non-trivial的解决方法，也许能发到较好的会议上；对于已有的问题，直接adapt RIS基本是收不到什么正面反馈的。毕竟，IM也已经是个被研究了22年的问题了，RIS也被提出十年有余，所以做变种问题时，还是要有一点新的结果才行。</p> <p>在这里我姑且列一些花式使用RR-sets的文章，读者们可以再挖挖会不会有什么新东西：</p> <p>Dynamic update: [6-10]</p> <p>Adaptive: [10-14]</p> <p>Varying constraints: [15-17]</p> <p>Real-valued RR-sets: [17-19]</p> <h1 id="理论之外">理论之外</h1> <p>IM作为一个科学问题，或者说数学问题，收获了不少研究者的关注，并且有不少先进算法已经被设计出来。但它离实际应用可以说相当远了，因为现实世界的传播模型根本没那么理想化，也就导致了实际的影响力可能并不具备单调和次模的性质，于是这些所谓的理论保证就都都成扯淡了。说到底，在二十一世纪，信息甚至不可能只通过用户构成的图结构进行传播（但也许这种传播也能抽象成图的形式，如异质图）。而研究这类更“现实”的传播模型，其实不好发表，因为复杂的机制往往不具备较好的性质，也就很难得到一些non-trivial的理论保证（当然，或许在其他方面能有一些有趣的结果）。做科研就是这么抽象，不能做太难的问题，不然做不出来，也不能做太简单的问题，直接就会lack of technical quality被拒。</p> <p>我认为信息传播仍是一个非常重要的研究课题，尤其是在这个信息大爆炸的时代。但仅靠图算法进行建模是非常局限的。如何分析现实世界中的信息传播，集成各种形式的传播模式，是一个有前景但难度很高的事情。</p> <p>在科研逐渐浮躁化，人均深度学习，很多phd三个月就能发一篇文章的今天，有多少人还有勇气迎难而上？</p> <h1 id="参考文献">参考文献</h1> <ol> <li>Kempe, D., Kleinberg, J., &amp; Tardos, É. (2003, August). Maximizing the spread of influence through a social network. In <em>Proceedings of the ninth ACM SIGKDD international conference on Knowledge discovery and data mining</em> (pp. 137-146).</li> <li>Borgs, C., Brautbar, M., Chayes, J., &amp; Lucier, B. (2014, January). Maximizing social influence in nearly optimal time. In <em>Proceedings of the twenty-fifth annual ACM-SIAM symposium on Discrete algorithms</em> (pp. 946-957). Society for Industrial and Applied Mathematics.</li> <li>Tang, Y., Xiao, X., &amp; Shi, Y. (2014, June). Influence maximization: Near-optimal time complexity meets practical efficiency. In <em>Proceedings of the 2014 ACM SIGMOD international conference on Management of data</em> (pp. 75-86).</li> <li>Tang, Y., Shi, Y., &amp; Xiao, X. (2015, May). Influence maximization in near-linear time: A martingale approach. In <em>Proceedings of the 2015 ACM SIGMOD international conference on management of data</em> (pp. 1539-1554).</li> <li>Tang, J., Tang, X., Xiao, X., &amp; Yuan, J. (2018, May). Online processing algorithms for influence maximization. In <em>Proceedings of the 2018 international conference on management of data</em> (pp. 991-1005).</li> <li>Ohsaka, N., Akiba, T., Yoshida, Y., &amp; Kawarabayashi, K. I. (2016). Dynamic influence analysis in evolving networks. <em>Proceedings of the VLDB Endowment</em>, <em>9</em>(12), 1077-1088.</li> <li>Peng, B. (2021). Dynamic influence maximization. <em>Advances in Neural Information Processing Systems</em>, <em>34</em>, 10718-10731.</li> <li>Yang, Y., Wang, Z., Pei, J., &amp; Chen, E. (2017). Tracking influential individuals in dynamic networks. <em>IEEE Transactions on Knowledge and Data Engineering</em>, <em>29</em>(11), 2615-2628.</li> <li>Chen, X., Song, Y., &amp; Tang, J. (2024, May). Link recommendation to augment influence diffusion with provable guarantees. In <em>Proceedings of the ACM Web Conference 2024</em> (pp. 2509-2518).</li> <li>Guo, Q., Feng, C., Zhang, F., &amp; Wang, S. (2023). Efficient algorithm for budgeted adaptive influence maximization: An incremental rr-set update approach. <em>Proceedings of the ACM on Management of Data</em>, <em>1</em>(3), 1-26.</li> <li>Han, K., Huang, K., Xiao, X., Tang, J., Sun, A., &amp; Tang, X. (2018). Efficient algorithms for adaptive influence maximization. <em>Proceedings of the VLDB Endowment</em>, <em>11</em>(9), 1029-1040.</li> <li>Huang, K., Tang, J., Han, K., Xiao, X., Chen, W., Sun, A., … &amp; Lim, A. (2020). Efficient approximation algorithms for adaptive influence maximization. <em>The VLDB Journal</em>, <em>29</em>(6), 1385-1406.</li> <li>Cautis, B., Maniu, S., &amp; Tziortziotis, N. (2019, July). Adaptive influence maximization. In <em>Proceedings of the 25th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining</em> (pp. 3185-3186).</li> <li>Tang, J., Huang, K., Xiao, X., Lakshmanan, L. V., Tang, X., Sun, A., &amp; Lim, A. (2019, June). Efficient approximation algorithms for adaptive seed minimization. In <em>Proceedings of the 2019 International Conference on Management of Data</em>(pp. 1096-1113).</li> <li>Sun, L., Huang, W., Yu, P. S., &amp; Chen, W. (2018, July). Multi-round influence maximization. In <em>Proceedings of the 24th ACM SIGKDD international conference on knowledge discovery &amp; data mining</em> (pp. 2249-2258).</li> <li>Zhang, S., Huang, Y., Sun, J., Lin, W., Xiao, X., &amp; Tang, B. (2023, August). Capacity constrained influence maximization in social networks. In <em>Proceedings of the 29th ACM SIGKDD conference on knowledge discovery and data mining</em> (pp. 3376-3385).</li> <li>Huang, Y., Zhang, S., Lakshmanan, L. V., Lin, W., Xiao, X., &amp; Tang, B. (2024). Efficient and Effective Algorithms for A Family of Influence Maximization Problems with A Matroid Constraint. <em>Proceedings of the VLDB Endowment</em>, <em>18</em>(2), 117-129.</li> <li>Chen, X., &amp; Tang, J. (2025, July). Scalable Link Recommendation for Influence Maximization. In <em>Proceedings of the 31st ACM SIGKDD Conference on Knowledge Discovery and Data Mining V. 1</em> (pp. 130-141).</li> <li>Rui, X., Wang, Z., Zhao, J., Sun, L., &amp; Chen, W. (2023). Scalable fair influence maximization. <em>Advances in Neural Information Processing Systems</em>, <em>36</em>, 66675-66691.</li> </ol>]]></content><author><name></name></author><category term="Research"/><summary type="html"><![CDATA[社交网络影响力最大化（Influence Maximization）问题自从2003年被Kempe等人提出，已经被研究了二十余年。那么，现在最先进的算法是否已经足够好了？这个领域是不是已经没得做了？还能往哪方面深挖（灌水）呢？]]></summary></entry><entry><title type="html">About *args and **kwargs</title><link href="https://chenxlong3.github.io/blog/2023/args-kwargs/" rel="alternate" type="text/html" title="About *args and **kwargs"/><published>2023-11-20T00:00:00+00:00</published><updated>2023-11-20T00:00:00+00:00</updated><id>https://chenxlong3.github.io/blog/2023/args-kwargs</id><content type="html" xml:base="https://chenxlong3.github.io/blog/2023/args-kwargs/"><![CDATA[<p>我们在阅读python一些库的官方文档或源码时，经常会遇到<code class="language-plaintext highlighter-rouge">*args</code>和<code class="language-plaintext highlighter-rouge">**kwargs</code>这样的参数（见下图）。这篇blog的目的是解释一下这俩奇怪的参数是什么意思，以及我们为什么要使用它们。</p> <p><img src="/assets/img/posts/args_kwargs/args_kwargs.png" style="width: 80%; height: auto; margin:auto; display:block;"/></p> <h1 id="args">*args</h1> <h2 id="向函数传递多个参数">向函数传递多个参数</h2> <p>假设要你写一个函数，它的输入是两个数，要求返回两个数的和。我们可以很轻松地写出下面的代码。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div> <p>另一种看起来更酷炫的写法是：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_sum</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</code></pre></div></div> <p>显然这个函数是正确的，然而这并不算是一个好的函数定义。如果我需要这个函数能够计算三数之和、四数之和呢？难道我们又要重新写两个函数吗？</p> <p>一个不错的方法是把<code class="language-plaintext highlighter-rouge">my_sum</code> 这个函数的输入换成一个list (tuple)，然后在内部遍历这个list求和。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_sum</span><span class="p">(</span><span class="n">num_list</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">num_list</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">num</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">my_sum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="c1"># 10
</span></code></pre></div></div> <p>其实这已经相当接近*args的作用了，我们暂且记住这个思路。</p> <h2 id="args的用法">*args的用法</h2> <p>将list传进我们写的函数里就要求我们每次调用都必须先创建好一个<code class="language-plaintext highlighter-rouge">list</code> (<code class="language-plaintext highlighter-rouge">tuple</code>)，而<code class="language-plaintext highlighter-rouge">*args</code>则不需要。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_sum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">num</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">my_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></div> <p>可见，如果我们定义一个函数时将它的形参写为<code class="language-plaintext highlighter-rouge">*args</code>，那这个函数就允许我们输入任意多的参数。而且在函数体内部，我们基本就将这个<code class="language-plaintext highlighter-rouge">args</code>看作是一个包含了这些参数的<code class="language-plaintext highlighter-rouge">tuple</code>。它是一个<code class="language-plaintext highlighter-rouge">tuple</code>而非<code class="language-plaintext highlighter-rouge">list</code>这一点可以通过下面的代码验证。我们知道，tuple里的元素是不允许进行修改的，这个性质很好地保护了我们传进来的参数，能够避免很多的误操作，如在函数内部更新了某变量的值。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_sum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">my_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1"># TypeError: 'tuple' object does not support item assignment
</span></code></pre></div></div> <h1 id="kwargs">**kwargs</h1> <p>直接从英文入手的话，kw可以看成是keyword的缩写。<code class="language-plaintext highlighter-rouge">**kwargs</code>支持我们用键值对的方式传入参数。</p> <h2 id="keyword-arguments">Keyword Arguments</h2> <p>上一部分的例子<code class="language-plaintext highlighter-rouge">my_sum</code>函数的功能非常单一。现在考虑另外一个函数，用于打印个人信息。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_info</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">university</span><span class="p">,</span> <span class="n">school</span><span class="p">,</span> <span class="n">student_id</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Name:</span><span class="sh">"</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">University:</span><span class="sh">"</span><span class="p">,</span> <span class="n">university</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">School:</span><span class="sh">"</span><span class="p">,</span> <span class="n">school</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Student ID:</span><span class="sh">"</span><span class="p">,</span> <span class="n">student_id</span><span class="p">)</span>
    <span class="k">return</span>

<span class="nf">print_info</span><span class="p">(</span><span class="sh">"</span><span class="s">John</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">SCUT</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">school of physics</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">6666</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># Name: John
# University: SCUT
# School: school of physics
# Student ID: 6666
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">print_info("John", "SCUT", "school of physics", "6666")</code>这种调用方法其实不是很好，因为我们需要记住每个位置对应的属性是什么，所以我们也经常会使用如下指定keyword的方法进行调用。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sh">"</span><span class="s">John</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">university</span><span class="o">=</span><span class="sh">"</span><span class="s">SCUT</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">school</span><span class="o">=</span><span class="sh">"</span><span class="s">school of physics</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">student_id</span><span class="o">=</span><span class="sh">"</span><span class="s">6666</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>然而，如果我想传入一个age的参数，这个程序就会报错，因为函数在定义的时候并没有包括这个参数。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sh">"</span><span class="s">John</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">university</span><span class="o">=</span><span class="sh">"</span><span class="s">SCUT</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">school</span><span class="o">=</span><span class="sh">"</span><span class="s">school of physics</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">student_id</span><span class="o">=</span><span class="sh">"</span><span class="s">6666</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">age</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

<span class="c1"># TypeError: print_info() got an unexpected keyword argument 'age'
</span></code></pre></div></div> <p>想要让这个函数对未知的属性也能正常运作，一个很简单的思路就是把输入改成一个字典。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_info</span><span class="p">(</span><span class="n">info_dict</span><span class="p">:</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">info_dict</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="sh">"</span><span class="s">: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
    <span class="k">return</span>

<span class="n">info_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">Name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">John</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">University</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">SCUT</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">School</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">School of Physics</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">Student ID</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">6666</span><span class="sh">"</span>
<span class="p">}</span>
<span class="nf">print_info</span><span class="p">(</span><span class="n">info_dict</span><span class="p">)</span>
<span class="c1"># Name: John
# University: SCUT
# School: School of Physics
# Student ID: 6666
</span></code></pre></div></div> <h2 id="kwargs的用法">**kwargs的用法</h2> <p><code class="language-plaintext highlighter-rouge">**kwargs</code>的用法其实和传入一个字典非常类似。如果我们定义函数时将参数写为<code class="language-plaintext highlighter-rouge">**kwargs</code> ，我们就可以通过keyword arguments来传入参数，并在函数内部访问<code class="language-plaintext highlighter-rouge">kwargs</code> 来获取具体关键词参数的键值对。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_info</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="sh">"</span><span class="s">: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
    <span class="k">return</span>

<span class="nf">print_info</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sh">"</span><span class="s">John</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">university</span><span class="o">=</span><span class="sh">"</span><span class="s">SCUT</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">school</span><span class="o">=</span><span class="sh">"</span><span class="s">school of physics</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">student_id</span><span class="o">=</span><span class="sh">"</span><span class="s">6666</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">age</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
</code></pre></div></div> <p>总结一下，<code class="language-plaintext highlighter-rouge">*args</code>和<code class="language-plaintext highlighter-rouge">**kwargs</code>允许我们向函数传入任意长度的位置参数（positional arguments）与关键词参数（keyword arguments）。下一部分，我们看看<code class="language-plaintext highlighter-rouge">*</code>和<code class="language-plaintext highlighter-rouge">**</code>是起到什么作用。</p> <h1 id="unpacking-operation--and-">Unpacking Operation (* and **)</h1> <p>在函数内部<code class="language-plaintext highlighter-rouge">args</code>是一个tuple，<code class="language-plaintext highlighter-rouge">kwargs</code>是一个dict。那么*和**到底是什么鬼东西？</p> <p><code class="language-plaintext highlighter-rouge">*</code>和<code class="language-plaintext highlighter-rouge">**</code>这两个操作符是对iteratable object（以下都以<code class="language-plaintext highlighter-rouge">list</code>为例）和<code class="language-plaintext highlighter-rouge">dict</code>的unpacking操作符。pack是打包，unpack就是从包里取出来。而我们的<code class="language-plaintext highlighter-rouge">list</code>和<code class="language-plaintext highlighter-rouge">dict</code>就可以看作是箱包。</p> <p>考虑这样一个问题，假设我们有一个list <code class="language-plaintext highlighter-rouge">l=[1, 2, 3]</code>，现在我们想把里面的元素放到另外一个list的某个位置上，使得我们另外一个list是<code class="language-plaintext highlighter-rouge">L=[0, 1, 2, 3, 4]</code>，那应该怎么操作呢？我们当然可以这样写</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
    <span class="n">L</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="n">L</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="c1"># [0, 1, 2, 3, 4]
</span></code></pre></div></div> <p>然而这种写法非常啰嗦。如果用我们前面学到的<code class="language-plaintext highlighter-rouge">*</code>操作符，我们可以更优雅地完成这个任务。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="c1"># [0, 1, 2, 3, 4]
</span></code></pre></div></div> <p>用一个例子来类比，就是我们出去旅游的时候打包行李箱，其他东西都装好了，然后留了个位置放电脑和充电器，我们就把电脑包打开，把里面的东西放进行李箱里，然后搞定了。</p> <p>对dict也是同理。我们可以用unpacking operator <code class="language-plaintext highlighter-rouge">**</code>来简便地完成一些任务。比如合并两个dict：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dict_1</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
<span class="n">dict_2</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">c</span><span class="sh">"</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
<span class="n">merged_dict</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">dict_1</span><span class="p">,</span> <span class="o">**</span><span class="n">dict_2</span><span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">merged_dict</span><span class="p">)</span>
<span class="c1"># {'a': 3, 'b': 1, 'c': 1}
</span></code></pre></div></div> <h1 id="conclusion">Conclusion</h1> <p>在这篇blog里，我们主要介绍了函数定义中<code class="language-plaintext highlighter-rouge">*args</code>和<code class="language-plaintext highlighter-rouge">**kwargs</code>的用法，以及<code class="language-plaintext highlighter-rouge">*</code>和<code class="language-plaintext highlighter-rouge">**</code>这两个unpacking操作符。</p>]]></content><author><name></name></author><category term="Techniques"/><summary type="html"><![CDATA[我们在阅读python一些库的官方文档或源码时，经常会遇到*args和**kwargs这样的参数（见下图）。这篇blog的目的是解释一下这俩奇怪的参数是什么意思，以及我们为什么要使用它们。]]></summary></entry><entry><title type="html">Include errors detected in VSCode - C++</title><link href="https://chenxlong3.github.io/blog/2023/include-error-cpp-vscode/" rel="alternate" type="text/html" title="Include errors detected in VSCode - C++"/><published>2023-06-17T00:00:00+00:00</published><updated>2023-06-17T00:00:00+00:00</updated><id>https://chenxlong3.github.io/blog/2023/include-error-cpp-vscode</id><content type="html" xml:base="https://chenxlong3.github.io/blog/2023/include-error-cpp-vscode/"><![CDATA[<p>The error message is like</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cannot open source file "iostream". Please run the 'Select IntelliSense Configuration...' command to locate your system headers.
</code></pre></div></div> <p><img src="./include-errors/Untitled.png" style="width: 80%; height: auto; margin:auto; display:block;"/></p> <ol> <li> <p>Click the bulb beside the error line</p> <p><img src="./include-errors/Untitled2_01.png" style="width: 80%; height: auto; margin:auto; display:block;"/></p> </li> <li>Click <code class="language-plaintext highlighter-rouge">Edit “compilerPath” setting</code></li> <li> <p>Select one from the list</p> <p><img src="./include-errors/Untitled2_02.png" style="width: 80%; height: auto; margin:auto; display:block;"/></p> </li> </ol> <p>Now the problem should be fixed.</p>]]></content><author><name></name></author><category term="Techniques"/><summary type="html"><![CDATA[The error message is like]]></summary></entry><entry><title type="html">Building wheels for torch_sparse takes forever</title><link href="https://chenxlong3.github.io/blog/2023/install-torch-sparse/" rel="alternate" type="text/html" title="Building wheels for torch_sparse takes forever"/><published>2023-03-24T00:00:00+00:00</published><updated>2023-03-24T00:00:00+00:00</updated><id>https://chenxlong3.github.io/blog/2023/install-torch-sparse</id><content type="html" xml:base="https://chenxlong3.github.io/blog/2023/install-torch-sparse/"><![CDATA[<p>安装torch_sparse包的时候，一直卡在building wheels这一步，可以通过以下方式解决：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>torch-sparse <span class="nt">-f</span> https://pytorch-geometric.com/whl/torch-1.8.0+cu101.html
</code></pre></div></div> <p>其中最后的”torch-1.8.0+cu101”按照自己的torch和cuda版本进行调整。</p> <p>参考：</p> <p>https://stackoverflow.com/questions/67285115/building-wheels-for-torch-sparse-in-colab-takes-forever</p> <p>https://github.com/pyg-team/pytorch_geometric/issues/5015</p>]]></content><author><name></name></author><category term="Techniques"/><summary type="html"><![CDATA[安装torch_sparse包的时候，一直卡在building wheels这一步，可以通过以下方式解决：]]></summary></entry><entry><title type="html">tmux 2.6设置鼠标滚轮滚动</title><link href="https://chenxlong3.github.io/blog/2023/tmux-scroll/" rel="alternate" type="text/html" title="tmux 2.6设置鼠标滚轮滚动"/><published>2023-03-24T00:00:00+00:00</published><updated>2023-03-24T00:00:00+00:00</updated><id>https://chenxlong3.github.io/blog/2023/tmux-scroll</id><content type="html" xml:base="https://chenxlong3.github.io/blog/2023/tmux-scroll/"><![CDATA[<ol> <li>ctrl + b</li> <li>Press :</li> <li>input</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span> <span class="nt">-g</span> mouse on
</code></pre></div></div> <p>If want to select and copy text, press shift then operate.</p>]]></content><author><name></name></author><category term="Techniques"/><summary type="html"><![CDATA[ctrl + b Press : input]]></summary></entry><entry><title type="html">VSCode+Jupyter在远程服务器上没有可选kernel</title><link href="https://chenxlong3.github.io/blog/2023/no-jupyter-kernel/" rel="alternate" type="text/html" title="VSCode+Jupyter在远程服务器上没有可选kernel"/><published>2023-03-20T00:00:00+00:00</published><updated>2023-03-20T00:00:00+00:00</updated><id>https://chenxlong3.github.io/blog/2023/no-jupyter-kernel</id><content type="html" xml:base="https://chenxlong3.github.io/blog/2023/no-jupyter-kernel/"><![CDATA[<p>首先安装jupyter和ipykernel</p> <p>可参考https://ipython.readthedocs.io/en/stable/install/kernel_install.html</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda <span class="nb">install </span>jupyter
conda <span class="nb">install </span>ipykernel
python <span class="nt">-m</span> ipykernel <span class="nb">install</span> <span class="nt">--user</span> <span class="nt">--name</span> myenv <span class="nt">--display-name</span> <span class="s2">"Python (myenv)"</span>
</code></pre></div></div> <p>然后在VSCode通过ssh连接的远程窗口中安装Jupyter拓展应用，如果一直卡在installing状态，在settings中搜索remote.downloadExtensionsLocally，把这个选项给勾选上，然后再安装就可以了。</p> <p>参考https://github.com/microsoft/vscode-remote-release/issues/1106</p>]]></content><author><name></name></author><category term="Techniques"/><summary type="html"><![CDATA[首先安装jupyter和ipykernel]]></summary></entry><entry><title type="html">Linux 相关命令</title><link href="https://chenxlong3.github.io/blog/2023/linux-command/" rel="alternate" type="text/html" title="Linux 相关命令"/><published>2023-03-11T00:00:00+00:00</published><updated>2023-03-11T00:00:00+00:00</updated><id>https://chenxlong3.github.io/blog/2023/linux-command</id><content type="html" xml:base="https://chenxlong3.github.io/blog/2023/linux-command/"><![CDATA[<p>vim:</p> <p><a href="https://www.runoob.com/linux/linux-vim.html">https://www.runoob.com/linux/linux-vim.html</a></p> <h1 id="scp">SCP</h1> <h2 id="download-files">Download files</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp <span class="nt">-P</span> &lt;Port&gt; &lt;User&gt;@&lt;IP/Host&gt;:&lt;File&gt; &lt;DestinationDirectory&gt;
</code></pre></div></div> <h2 id="download-directories">Download Directories</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp <span class="nt">-rP</span> &lt;Port&gt; &lt;User&gt;@&lt;IP/Host&gt;:&lt;Dir&gt; &lt;DestinationDirectory&gt;
</code></pre></div></div> <h2 id="uploading-files"><strong>Uploading Files</strong></h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp <span class="nt">-P</span> &lt;Port&gt; &lt;File&gt; &lt;User&gt;@&lt;IP/Host&gt;:&lt;DestinationDir&gt;
</code></pre></div></div> <h2 id="uploading-directories">Uploading Directories</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp <span class="nt">-rP</span> &lt;Port&gt; &lt;Dir&gt; &lt;User&gt;@&lt;IP/Host&gt;:&lt;DestinationDir&gt;
</code></pre></div></div> <p>Git配置ssh key</p> <p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh">https://docs.github.com/en/authentication/connecting-to-github-with-ssh</a></p> <h1 id="unzip-gz-file">Unzip .gz file</h1> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">gzip</span> <span class="nt">-d</span> file.gz
</code></pre></div></div> <p><a href="https://linuxize.com/post/how-to-unzip-gz-file/">https://linuxize.com/post/how-to-unzip-gz-file/</a></p> <h1 id="run-sh-file-shell-script">Run .sh file shell script</h1> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod +x script.sh
</code></pre></div></div> <h1 id="output-the-message-in-both-console-and-a-file">Output the message in both console and a file</h1> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make | <span class="nb">tee </span>output.txt
</code></pre></div></div> <p><a href="https://unix.stackexchange.com/questions/274168/display-output-from-command-and-save-to-file">https://unix.stackexchange.com/questions/274168/display-output-from-command-and-save-to-file</a></p> <h1 id="list-directories-and-size">List Directories and size</h1> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">du</span> <span class="o">-</span><span class="nx">h</span> <span class="o">--</span><span class="nx">max_depth</span><span class="o">=</span><span class="mi">1</span> <span class="o">|</span> <span class="nx">sort</span> <span class="o">-</span><span class="nx">h</span>
</code></pre></div></div> <p><a href="https://linuxconfig.org/list-all-directories-and-sort-by-size">https://linuxconfig.org/list-all-directories-and-sort-by-size</a></p> <h1 id="git">Git</h1> <p>Multiple github accounts</p> <p><a href="https://stackoverflow.com/questions/3860112/multiple-github-accounts-on-the-same-computer">https://stackoverflow.com/questions/3860112/multiple-github-accounts-on-the-same-computer</a></p> <h1 id="服务器使用">服务器使用</h1> <p>怎么熟练使用服务器并避免给实验室添麻烦呢？ - Seasoning的回答 - 知乎 <a href="https://www.zhihu.com/question/506241986/answer/3457669268">https://www.zhihu.com/question/506241986/answer/3457669268</a></p> <h2 id="gpu运行脚本">GPU运行脚本</h2> <p><a href="https://www.cnblogs.com/lixinliang/p/18043057">占用GPU显卡资源的脚本 - lixinliang - 博客园</a></p> <h1 id="conda">Conda</h1> <p>Install:</p> <p><a href="https://repo.anaconda.com/archive/index.html">https://repo.anaconda.com/archive/index.html</a></p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">wget</span> <span class="o">-</span><span class="nx">c</span> <span class="p">[</span><span class="nx">url</span><span class="p">]</span>
</code></pre></div></div> <p>Run the script in terminal</p> <p><a href="https://blog.csdn.net/zyctimes/article/details/124598774">Conda 的 yml 文件 Conda/PIP 国内镜像源的添加_conda 安装yaml文件怎么设置镜像-CSDN博客</a></p>]]></content><author><name></name></author><category term="Techniques"/><summary type="html"><![CDATA[vim:]]></summary></entry><entry><title type="html">ssh免密登陆配置</title><link href="https://chenxlong3.github.io/blog/2023/ssh-nopwd/" rel="alternate" type="text/html" title="ssh免密登陆配置"/><published>2023-02-24T00:00:00+00:00</published><updated>2023-02-24T00:00:00+00:00</updated><id>https://chenxlong3.github.io/blog/2023/ssh-nopwd</id><content type="html" xml:base="https://chenxlong3.github.io/blog/2023/ssh-nopwd/"><![CDATA[<p>本地终端：当前在用的计算机的终端</p> <p>服务器终端：远程服务器的终端</p> <h1 id="1-查看本地私钥文件">1. 查看本地私钥文件</h1> <p>首先我们查看本地是否有ssh的私钥，在本地终端输入</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> .ssh
<span class="nb">ls</span>
</code></pre></div></div> <p>如果这个文件夹里有”id_rsa”，那么我们可以选择直接跳到步骤2。</p> <p>如果没有这个文件，我们需要在本地终端输入</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh-keygen <span class="nt">-t</span> rsa
</code></pre></div></div> <p>一路回车，我们就可以在.ssh目录下生成”id_rsa”和”id_rsa.pub”文件。</p> <h1 id="2-远程拷贝">2. 远程拷贝</h1> <p>在这一步，我们将生成的”id_rsa.pub”文件拷贝到远程服务器的~/.ssh目录下</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	scp &lt;local_id_rsa_pub_path&gt; &lt;user@ip&gt;:~/.ssh
</code></pre></div></div> <local_id_rsa_pub_path>为本地计算机”id_rsa.pub”文件的路径。 &lt;user@ip&gt;为一般ssh连接的格式，远程服务器的用户以及ip。例子：root@10.16.16.12 # 3. 公钥追加到授权KEY中 如果远程服务器上已经存在”~/.ssh/authorized_keys”文件，在服务器终端输入 ```bash cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys ``` 意义就是将公钥的内容追加到”~/.ssh/authorized_keys”中。 如果远程服务器上没有该文件，那么在服务器终端输入 ```bash cp id_rsa.pub authorized_keys ``` 即将公钥复制为authorized_keys文件。 # 4. 进行测试 # 5. 更改ssh别名 每次要输入ip事实上是一个不太优雅的方式。我们可以通过修改本地的”~/.ssh/config”文件，将Host修改为自己设置的别名，比如修改成如下格式 ```bash Host **server** HostName 12.130.15.23 Port 16742 User root ``` 随后我们就可以直接通过 ```bash ssh server ``` 访问远程服务器。 # 参考 [https://www.jianshu.com/p/e9db116fef8c](https://www.jianshu.com/p/e9db116fef8c) [https://stackoverflow.com/questions/57734669/gitgithub-com-permission-denied-publickey](https://stackoverflow.com/questions/57734669/gitgithub-com-permission-denied-publickey) </local_id_rsa_pub_path>]]></content><author><name></name></author><category term="Techniques"/><summary type="html"><![CDATA[本地终端：当前在用的计算机的终端]]></summary></entry></feed>