<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://chenxlong3.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://chenxlong3.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-01-15T07:10:27+00:00</updated><id>https://chenxlong3.github.io/feed.xml</id><title type="html">Xiaolong Chen</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">线性回归：机器学习的“Hello, World“</title><link href="https://chenxlong3.github.io/blog/2021/linear-regression/" rel="alternate" type="text/html" title="线性回归：机器学习的“Hello, World“"/><published>2021-06-16T20:41:18+00:00</published><updated>2021-06-16T20:41:18+00:00</updated><id>https://chenxlong3.github.io/blog/2021/linear-regression</id><content type="html" xml:base="https://chenxlong3.github.io/blog/2021/linear-regression/"><![CDATA[<h1 id="想要解决的问题">想要解决的问题</h1> <p>假设我们知道若干房子的面积以及对应的房价，那么如果随便告诉我们一套房子的面积，怎么才能知道这套房子最可能买多少钱呢？再假设我们知道了一些零件的使用时间和对应的维修费用，那么如果告诉我们一个零件的使用时间，我们要怎样推测出来对应的维修费用呢？没错，线性回归就是用来解决这些问题的，也就是通过拟合曲线来进行预测。</p> <h1 id="线性回归linear-regression">线性回归（Linear Regression）</h1> <p>线性回归大体分为三个部分，选择合适的模型（model），确定损失函数，梯度下降求解最优参数。</p> <h2 id="选择模型model">选择模型（Model）</h2> <p>首先我们要知道模型（model）是什么，在这个问题中，我们所说的model是指一个函数族。我们最终想要的结果，就是输入一个$x$，得到一个十分可信的输出$\hat{y}$，其实也就是找一个比较好的<strong>函数</strong>而已。问题是，这种函数可能有非常多，以单变量线性回归为例子，我们可以提出以下函数来进行拟合：</p> \[\begin{aligned} \hat{y} &amp;= \theta_0 + \theta_1 x \\ \hat{y} &amp;= \theta_0 + \theta_1 x + \theta_2 x^2\\ \hat{y} &amp;= \theta_0 + \theta_1 x + \theta_2 x^2 + \theta_3 x^3\\ \vdots \end{aligned}\] <p>同样地，我们挑一个最简单的，也就是第一个函数。</p> \[\hat{y} = \theta_0 + \theta_1 x\] <p>很显然，我们的最终目标就是找出$\theta_0$和$\theta_1$使得这个函数足够准确。那么问题又来了，我们要怎么样判断这个函数是否<strong>足够准确</strong>呢？</p> <h2 id="损失函数loss-function">损失函数（Loss function）</h2> <p>我们在说<strong>准确</strong>这个词的时候，实际上是在讨论什么？是<strong>误差</strong>。足够准确，也就是说误差足够小。损失函数（Loss function）就是用来描述这个误差的。如果要衡量误差，直接用预测值减去实际值就可以得出来了，如下：</p> \[\delta = \hat{y} - y\] <p>对于单个数据点我们当然可以这样做，那对于一堆数据点呢？一个很简单的想法就是直接将多个点的误差相加，问题是如果正的误差和负的误差相加起来抵消掉了怎么办。比如我们现在测量一个5cm的木块，第一次测出来是4.9cm，此时的误差就是-0.1cm，第二次测出来是5.1cm，此时的误差就是0.1cm。两次误差加起来就是0了，那岂不是相当于没有误差？那么现在聪明的你应该会想到，可以用绝对值。没错，这确实是一个可以选择的方式，然而，在实际应用中，带有绝对值的变量往往在求导等操作上会有一点麻烦。所以我们选用另一种方法，就是把这个数平方，即：</p> \[\delta = (\hat{y} - y)^2\] <p>同样，上式也是对一个数据点的计算，如果有多个数据点，假如一共有$m$个，直接相加的话，得到的就是所有数据点的误差之和了，但是当数据点非常多时，这个数字就变得很大了，为了方便计算，我们在前面再除以一个数据点的数量，也就得到了我们的损失函数（Loss function）：</p> \[L(\theta_0, \theta_1) = \frac{1}{m}\sum_{i=1}^m(\hat{y}^{(i)} - y)^2\] <p>（$\hat{y}^{(i)}$里的上标$(i)$表示第$i$个数据点） 好的，那么现在我们会发现数学符号逐渐多了起来，但是没有关系，我们把整个过程捋一捋。</p> <p>还记得我们的model吗？就是下面这个：</p> \[\hat{y} = \theta_0 + \theta_1 x\] <p>我们的任务是什么，就是找到最合适的$\theta_0$和$\theta_1$，使得上式可以取得较好的预测结果。怎么评估这种<strong>合适</strong>程度呢，我们将会用Loss函数来描述。不断改变$\theta_0$和$\theta_1$的值，利用手上已有的数据 ${ (x^{(1),} y^{(1)}), (x^{(2),} y^{(2)}), (x^{(3),} y^{(3)}), \dots, (x^{(m),} y^{(m)}) }$计算出Loss函数的值即可。那么什么时候才算是找到了最合适的$\theta_0$和$\theta_1$呢，显然，就是Loss函数最小的时候。误差最小就代表最准确，这是非常明显的。</p> <p>那么接下来，我们会介绍一种求解$\theta_0$和$\theta_1$的最常用的方法，梯度下降法（Gradient Descent）。</p> <h2 id="梯度下降法gradient-descent">梯度下降法（Gradient Descent）</h2> <p>经过高中数学的学习，想必大家都知道了导数的几何意义，在某一点的导数就等于过这一点切线的斜率，如下图所示：</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/linear-regression/LR1-480.webp 480w,/assets/img/posts/linear-regression/LR1-800.webp 800w,/assets/img/posts/linear-regression/LR1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/linear-regression/LR1.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>显然，在$x_1$处的导数小于0，意味着在这个点的右边还有会使$y$更小的$x$值，暗示我们向右取值；相反地，在$x_2$处的导数大于0，意味着在这个点的左边有能使$y$更小的$x$值，暗示我们向左取值。所以就有如下的迭代策略：</p> \[\theta_j := \theta_j - \eta \frac{\partial}{\partial \theta_j}L(\theta_0, \theta_1) \ \ \ \ \ \ \ \ (j = 0, 1)\] <p>公式逐渐复杂了起来，不过问题不大，我们来分析一下各个参数的意义。</p> <p>$\theta_j$：就是代指$\theta_0$和$\theta_1$</p> <p>$:=$是<strong>赋值</strong>的意思，让左边的数等于右边的数</p> <p>$\eta$：学习率（Learning Rate），把降低Loss函数的过程比喻成下山，那么学习率$\eta$就是下山的步长，<del>步子跨大了容易扯着蛋</del>，步子跨大了就可能一步走到另外一边的上坡路去了，但是步子小了就会走得很慢。</p> <p>$\frac{\partial}{\partial \theta_j}L(\theta_0, \theta_1)$：Loss函数对$\theta_j$的偏导，可以大概理解为其余变量为常数时，对单变量的导数。</p> <p>总的来说，整个过程我们就是在变化$\theta_0, \theta_1$，利用训练集（Training Data）来让我们的“假想函数”与实际的差距越来越小。</p> <h2 id="求导公式">求导公式</h2> <p>我们这里把Loss函数的形式写完整：</p> \[L(\theta_0, \theta_1) = \sum_{i=1}^m(\hat{y}^{(i)} - y)^2 = \sum_{i=1}^m(\theta_0+\theta_1x^{(i)}-y^{(i)})^2\] <p>那么两个参数的偏导数就如下所示：</p> \[\frac{\partial}{\partial \theta_0}L(\theta_0, \theta_1)=\frac{2}{m} \sum_{i=1}^m(\theta_0+\theta_1x^{(i)}-y^{(i)})\] \[\frac{\partial}{\partial \theta_1}L(\theta_0, \theta_1)=\frac{2}{m} \sum_{i=1}^m(\theta_0+\theta_1x^{(i)}-y^{(i)}) \cdot x^{(i)}\] <h3 id="拓展幂次">拓展（幂次）</h3> <p>Loss函数构造的思想依然是一样的，只是我们选取的model发生变化了，当然，也就意味着偏导数的形式也发生变化了。假设我们一开始选取的model如下：</p> \[\hat{y} = \theta_0 + \theta_1 x + \theta_2 x^2 + \dots + \theta_n x^n\] <p>那么偏导数的形式变为：</p> \[\frac{\partial}{\partial \theta_0}L(\theta_0, \theta_1, \dots, \theta_n)=\frac{2}{m} \sum_{i=1}^m(\theta_0+\theta_1x^{(i)}+\dots + \theta_n x^{(i)n}-y^{(i)})\] \[\frac{\partial}{\partial \theta_j}L(\theta_0, \theta_1, \dots, \theta_n)=\frac{2}{m} \sum_{i=1}^m(\theta_0+\theta_1x^{(i)}+\dots + \theta_n x^{(i)n}-y^{(i)})\cdot x^{(i)j}\] <p>其中$j$取$1, 2, \dots, n$.</p>]]></content><author><name></name></author><category term="Learning"/><summary type="html"><![CDATA[想要解决的问题]]></summary></entry><entry><title type="html">纯粹直觉地理解主成分分析 (PCA)</title><link href="https://chenxlong3.github.io/blog/2021/pca/" rel="alternate" type="text/html" title="纯粹直觉地理解主成分分析 (PCA)"/><published>2021-06-16T09:50:54+00:00</published><updated>2021-06-16T09:50:54+00:00</updated><id>https://chenxlong3.github.io/blog/2021/pca</id><content type="html" xml:base="https://chenxlong3.github.io/blog/2021/pca/"><![CDATA[<h1 id="引言">引言</h1> <p>写这篇blog只是分享一下个人对于PCA的直观理解，并不涉及严谨的数学推导，懒是一个原因，而且自己对线性代数的SVD那些知识掌握得还不够熟练，这里就不班门弄斧了。</p> <h1 id="降维的思想">降维的思想</h1> <p>要了解某个物体，我们往往会关注它的多个特性（或者叫多个维度）。假设这里有n个特性，那么对于每一个样本，我们可以用n维空间的某一个点来表示：</p> \[(x_1, x_2 , \dots, x_n)\] <p>然而，这些特性中，会存在某一些高度相关的特性，比如在评价一个人时，他/她的总财产和月收入一般是正相关的，那么我们是否可以只用一个数来描述这个人的富有程度呢？显然是可以的。事实上，这样的想法就基本上是降维的思路了。如果按照上述例子的思路，我们就可以把一个n维空间的点，变成一个n-1维空间的点了。</p> <h1 id="主成分分析">主成分分析</h1> <p>事实上，主成分分析的实质就是<strong>坐标轴的变换</strong>，然后舍弃掉贡献较小的变量。</p> <p>在这里提一下，很多教程喜欢把中心化(centralizing)放在前面讲，但事实上这个操作只是把坐标原点进行平移而已，并不涉及PCA的实质，暂且不提。</p> <p><img src="/assets/img/posts/pca/pca1.jpg" style="width: 80%; height: auto; margin:auto; display:block;"/></p> <p>如上图所示，我们用了新的一组变量$(PC_1 , PC_2)$来代替原来的变量$(x_1, x_2)$。显然，在新的坐标下，数据点在$PC_2$方向上的分散较小，若在误差范围内，可以忽略。这样，我们就可以只用$PC_1$一个变量来描述这些数据点了。</p> <p>根据线性代数的知识，我们可以知道这里其实就涉及到基变换的知识了。同样地，这也是个非常“数学”的过程，等以后有时间再写。简单来说，新的变量组是旧变量组的线性组合。</p> <h1 id="另一种看法">另一种看法</h1> <p>不难发现，上述对于PCA的理解其实有点类似Linear Regression。现在我们用另外一种角度来考虑PCA。前面提到，新的变量组是旧变量组的线性组合，那就可以写成如下格式：</p> \[\begin{cases} PC_1 = c_{11}x_1 + c_{12}x_2 + \dots +c_{1n}x_n \\ PC_2 = c_{21}x_1 + c_{22}x_2 + \dots +c_{2n}x_n \\ \vdots \\ PC_n = c_{n1}x_1 + c_{n2}x_2 + \dots +c_{nn}x_n \end{cases}\] <p>问题是系数$c_{ii}$的选取，以什么作为原则呢？因为我们最终目的是降维，也就是说要把尽量多的<strong>特征</strong>保留在前几个主成分中。这意味着什么呢？如果两个点投影到一个轴上之后重合成一个点，那么这两个点的区分度就变小了，也就是说，在降维之后，用于描述这两个点的特征变少了。那么直观上怎么样才算是保留了较多的<strong>特征</strong>呢？事实上， 这就是要求样本点在新的轴上的分布尽量分散。很容易联想到，描述样本分散程度的数学量就是方差。所以我们要做的事情也就是使$Var(PC_1)$最大化。</p> <p>这两种看法实际上是一样的，设样本点到新坐标轴的距离为$h$，点 $\overline{x}$ 的坐标为$(\overline{x_1}, \overline{x_2}, \dots, \overline{x _n})$，样本点在新坐标轴上的投影到点 $\overline{x}$ 的距离为$d$。因为样本点到点 $\overline{x}$ 点的距离是一定的，那么根据勾股定理，如果我们要求$h$尽量小，实际上等价于要求$d$尽量大。</p> <p><img src="/assets/img/posts/pca/pca2.jpg" style="width: 80%; height: auto; margin:auto; display:block;"/></p> <p>上述的证明默认了新的坐标轴是经过点 $\overline{x}$ 的，其实这也就是中心化。</p> <h1 id="碎碎念">碎碎念</h1> <p>PCA的数学公式推导暂且先留个坑，希望以后会有时间搞一搞。不得不说孔子讲得还真对，温故而知新。线性代数这门学科越是反复看就越是觉得有意思，当然也确实有点难度，等到一切尘埃落定之后会好好整理一下这些知识。</p>]]></content><author><name></name></author><category term="Learning"/><summary type="html"><![CDATA[引言 写这篇blog只是分享一下个人对于PCA的直观理解，并不涉及严谨的数学推导，懒是一个原因，而且自己对线性代数的SVD那些知识掌握得还不够熟练，这里就不班门弄斧了。]]></summary></entry></feed>